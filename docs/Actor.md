# Actor
1. Actor Model 的起源與發展：
- 1973年由 Hewitt、Bishop 和 Steiger 首次提出
- 受到物理學（包括相對論和量子力學）的啟發
- 也受到 Lisp、Simula 等程式語言的影響 🌱

2. Actor Model 的核心概念：
- Actor 是並發計算的基本單位
- 每個 Actor 都有自己的私有狀態
- Actor 之間只能通過消息傳遞進行通信
- 不需要基於鎖的同步機制 🔄

3. Actor Model 的主要特點：
- 響應消息時，Actor 可以：
  * 做出本地決策
  * 創建更多 Actor
  * 發送更多消息
  * 決定如何處理下一個消息
- 完全異步的通信模型
- 天然支持分布式系統 💫

## **Actor 模型如何滿足現代分散式系統的需求**

正如前一主題所述，常見的程式設計實務並未適當地解決現代系統的需求。幸運的是，我們不必拋棄所有已知知識。相反地，Actor 模型以有原則的方式解決了這些缺點，使系統的行為更符合我們的心理模型。Actor 模型的抽象概念讓我們從溝通的角度來思考程式碼，就像大型組織中人與人之間的交流一樣。

使用 Actor 可以讓我們：

*   **強制執行封裝，而無需使用鎖。**
*   **使用協作實體反應訊號、改變狀態以及互相發送訊號的模型來推動整個應用程式的運行。**
*   **不再擔心與我們世界觀不符的執行機制。**

**訊息傳遞的使用避免了鎖定和阻塞**

Actor 之間透過發送訊息來互動，而非直接呼叫方法。發送訊息不會將執行緒從發送者轉移到接收者。Actor 可以發送訊息並繼續執行，而不會被阻塞。因此，它可以在相同的時間內完成更多工作。

當物件的方法返回時，它會釋放其執行緒的控制權。在這方面，Actor 的行為很像物件，它們對訊息做出反應，並在完成處理當前訊息後返回執行權。這樣，Actor 實際上實現了我們對物件的想像：

*   Actor 之間透過發送訊息來互動

傳遞訊息和呼叫方法之間的重要區別在於訊息沒有回傳值。透過發送訊息，Actor 將工作委派給另一個 Actor。正如我們在「呼叫堆疊的幻覺」中所見，如果它期望一個回傳值，發送 Actor 要麼需要阻塞，要麼需要在同一個執行緒上執行另一個 Actor 的工作。相反，接收 Actor 會在回覆訊息中傳遞結果。

我們模型中需要的第二個關鍵改變是恢復封裝。Actor 對訊息做出反應，就像物件對在其上呼叫的方法「做出反應」一樣。不同之處在於，不是多個執行緒「伸入」我們的 Actor 並破壞其內部狀態和不變性，而是 Actor 獨立於訊息的發送者執行，並且它們依序一次處理一個傳入的訊息。雖然每個 Actor 依序處理發送給它的訊息，但不同的 Actor 可以彼此並行工作，以便一個 Actor 系統可以同時處理與硬體所支援的一樣多的訊息。

由於每個 Actor 始終最多處理一條訊息，因此可以在沒有同步的情況下保持 Actor 的不變性。這會自動發生，無需使用鎖：

*   訊息在依序處理時不會使不變性失效

總之，當一個 Actor 收到訊息時，會發生以下情況：

1.  Actor 將訊息添加到隊列的末尾。
2.  如果 Actor 未被排程執行，則將其標記為準備執行。
3.  一個（隱藏的）排程器實體取得該 Actor 並開始執行它。
4.  Actor 從隊列的前端選擇訊息。
5.  Actor 修改內部狀態，向其他 Actor 發送訊息。
6.  Actor 被取消排程。

為了實現這種行為，Actor 具有：

*   **信箱**（訊息最終進入的隊列）。
*   **行為**（Actor 的狀態、內部變數等）。
*   **訊息**（代表訊號的資料片段，類似於方法呼叫及其參數）。
*   **執行環境**（將有訊息要反應的 Actor 取出並調用其訊息處理程式碼的機制）。
*   **位址**（稍後詳細介紹）。

訊息會進入 Actor 的信箱。Actor 的行為描述了 Actor 如何回應訊息（例如發送更多訊息和/或改變狀態）。執行環境協調一個執行緒池，以完全透明地驅動所有這些動作。

這是一個非常簡單的模型，它可以解決先前列舉的問題：

*   透過將執行與訊號分離來保留封裝（方法呼叫會轉移執行權，訊息傳遞則不會）。
*   無需使用鎖。修改 Actor 的內部狀態只能透過訊息進行，而訊息是一次處理一條，從而消除了在嘗試保持不變性時發生的競爭。
*   任何地方都不使用鎖，並且發送者不會被阻塞。可以在十幾個執行緒上有效地排程數百萬個 Actor，充分發揮現代 CPU 的潛力。任務委派是 Actor 的自然操作模式。
*   Actor 的狀態是本地的且不共享，變更和資料透過訊息傳播，這對應於現代記憶體層級的實際運作方式。在許多情況下，這意味著僅傳輸包含訊息中資料的快取行，同時將本地狀態和資料快取在原始核心中。相同的模型也完全對應於遠端通訊，其中狀態保存在機器的 RAM 中，而變更/資料則以封包形式在網路中傳播。

**Actor 優雅地處理錯誤情況**

由於我們在互相發送訊息的 Actor 之間不再有共享的呼叫堆疊，因此我們需要以不同的方式處理錯誤情況。我們需要考慮兩種錯誤：

1.  第一種情況是當目標 Actor 上委派的任務由於任務中的錯誤而失敗時（通常是一些驗證問題，例如不存在的使用者 ID）。在這種情況下，目標 Actor 封裝的服務是完整的，只有任務本身是錯誤的。服務 Actor 應該向發送者回覆一條訊息，呈現錯誤情況。這裡沒有什麼特別的，錯誤是領域的一部分，因此變成了普通的訊息。
2.  第二種情況是當服務本身遇到內部故障時。Akka 強制所有 Actor 組織成樹狀層次結構，也就是說，建立另一個 Actor 的 Actor 會成為該新 Actor 的父 Actor。這與作業系統如何將進程組織成樹狀結構非常相似。就像進程一樣，當一個 Actor 失敗時，其父 Actor 可以決定如何對失敗做出反應。此外，如果父 Actor 停止，其所有子 Actor 也會被遞迴地停止。此服務稱為監管，它對於 Akka 至關重要。

監管策略通常由父 Actor 在啟動子 Actor 時定義。它可以決定在某些類型的失敗時重新啟動子 Actor，或在其他類型的失敗時完全停止它。子 Actor 永遠不會悄無聲息地死亡（除了進入無限迴圈的情況），而是它們要么失敗，並且監管策略可以對故障做出反應，要么它們被停止（在這種情況下，會通知有關方面）。始終有一個負責管理 Actor 的實體：它的父 Actor。重新啟動對外部不可見：協作的 Actor 可以在目標 Actor 重新啟動時繼續發送訊息。
